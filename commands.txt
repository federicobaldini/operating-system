The linker is a program that combines the generated code into an executable.
Since the executable format differs between Linux, Windows, and macOS, each system has its own
linker that throws a different error. The fundamental cause of the errors
is the same: the default configuration of the linker assumes that our program depends on the C runtime,
which it does not.

To solve the errors, we need to tell the linker that it should not include the C runtime. We can do
this either by passing a certain set of arguments to the linker or by building for a bare metal target.

Building for a Bare Metal Target
By default Rust tries to build an executable that is able to run in your current system environment.
For example, if you’re using Windows on x86_64, Rust tries to build an .exe Windows executable that uses
x86_64 instructions. This environment is called your “host” system.

To describe different environments, Rust uses a string called target triple. You can see the target
triple for your host system by running rustc --version --verbose:

rustc 1.35.0-nightly (474e7a648 2019-04-07)
binary: rustc
commit-hash: 474e7a6486758ea6fc761893b1a49cd9076fb0ab
commit-date: 2019-04-07
host: x86_64-unknown-linux-gnu
release: 1.35.0-nightly
LLVM version: 8.0

The above output is from a x86_64 Linux system. We see that the host triple is x86_64-unknown-linux-gnu,
which includes the CPU architecture (x86_64), the vendor (unknown), the operating system (linux), and the ABI (gnu).

By compiling for our host triple, the Rust compiler and the linker assume that there is an underlying
operating system such as Linux or Windows that uses the C runtime by default, which causes the linker
errors. So, to avoid the linker errors, we can compile for a different environment with no underlying operating system.

An example of such a bare metal environment is the thumbv7em-none-eabihf target triple, which describes an
embedded ARM system. The details are not important, all that matters is that the target triple has no underlying
operating system, which is indicated by the none in the target triple. To be able to compile for this target,
we need to add it in rustup:

rustup target add thumbv7em-none-eabihf

This downloads a copy of the standard (and core) library for the system. Now we can build our freestanding
executable for this target:

cargo build --target thumbv7em-none-eabihf

By passing a --target argument we cross compile our executable for a bare metal target system. Since the target
system has no operating system, the linker does not try to link the C runtime and our build succeeds without
any linker errors.

This is the approach that we will use for building our OS kernel. Instead of thumbv7em-none-eabihf, we will use
a custom target that describes a x86_64 bare metal environment.

_______________

To resume: to build the binary, we need to compile for a bare metal target such as thumbv7em-none-eabihf:

cargo build --target thumbv7em-none-eabihf

Alternatively, we can compile it for the host system by passing additional linker arguments:

# Linux
cargo rustc -- -C link-arg=-nostartfiles
# Windows
cargo rustc -- -C link-args="/ENTRY:_start /SUBSYSTEM:console"
# macOS
cargo rustc -- -C link-args="-e __start -static -nostartfiles"

_______________________________________________________________________________________________________________